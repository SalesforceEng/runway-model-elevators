type PersonId: 1..5;
type ElevatorId: 1..3;
type Floor: 1..6;

type Person: either {
  Sleeping {
    floor: Floor,
  },
  Waiting {
    floor: Floor,
    destination: Floor,
  },
  Riding {
    elevator: ElevatorId,
    destination: Floor,
  },
}
var people: Array<Person>[PersonId];

type FloorControl: record {
  downActive: Boolean,
  upActive: Boolean,
}
var floorControls: Array<FloorControl>[Floor];

type Doors : either {
  Closed,
  Opening {
    startAt: Time,
    doneAt: Time,
  },
  Open { closeAt: Time },
  Closing {
    startAt: Time,
    doneAt: Time,
  },
}

type Elevator: record {
  destinations: Set<Floor>[Floor],
  riders: Set<PersonId>[PersonId],
  direction: either {
    Up,
    Down,
  },
  location: either {
    AtFloor {
      at: Floor,
      doors: Doors,
    },
    Between {
      next: Floor,
      leftAt: Time,
      nextAt: Time,
      // doors are closed for safety purposes
    },
  },
}
var elevators: Array<Elevator>[ElevatorId];

distribution makeDestination(start: Floor) -> Floor {
  while (True) {
    var f : Floor = urandom<Floor>();
    if f != start {
      return f;
    }
  }
}

function doorsOpen(doors: Doors) -> Boolean {
  match doors {
    Open    => { return True; },
    Closed  => { return False; },
    Opening => { return False; },
    Closing => { return False; },
  }
}

rule move for elevator in elevators {
  match elevator.location {
    Between as b => {
      if past(b.nextAt) {
        elevator.location = AtFloor { at: b.next, doors: Closed };
      }
    }, // end Between
    AtFloor as f => {
      if f.doors == Closed && !contains(elevator.destinations, f.at) {
        match elevator.direction {
          Up => {
            if f.at < 6 {
              for dest in elevator.destinations {
                if dest > f.at {
                  elevator.location = Between {
                    next: f.at + 1,
                    leftAt: later(0),
                    nextAt: later(10000),
                  };
                  break;
                }
              }
            }
          },
          Down => {
            if f.at > 1 {
              for dest in elevator.destinations {
                if dest < f.at {
                  elevator.location = Between {
                    next: f.at - 1,
                    leftAt: later(0),
                    nextAt: later(10000),
                  };
                  break;
                }
              }
            }
          },
        }
      } // end Closed
    } // end AtFloor
  } // end match
}

rule changeDirection for elevator in elevators {
  match elevator.location {
    AtFloor as f => {
      if f.doors == Closed {
        var smaller : Boolean = False;
        var larger : Boolean = False;
        for floor in elevator.destinations {
          if floor < f.at {
            smaller = True;
          }
          if floor > f.at {
            larger = True;
          }
        }
        match elevator.direction {
          Up => {
            if f.at > 1 && smaller && !larger {
              elevator.direction = Down;
            }
          },
          Down => {
            if f.at < 6 && larger && !smaller {
              elevator.direction = Up;
            }
          },
        }
      }
    },
    Between as b => { /* no turning here */ },
  }
}

// one person decides he/she wants to move floors and presses the up/down
// button (Sleeping to Waiting)
external wake for person in people {
  match person {
    Sleeping as s => {
      var dest : Floor = makeDestination(s.floor);
      assert dest != s.floor;
      person = Waiting {
        floor: s.floor,
        destination: dest,
      };
    },
    Waiting => { /* do nothing */ },
    Riding => { /* do nothing */ },
  }
}

rule requestElevator for floor, control in floorControls {
  if control.upActive || control.downActive {
    var eid : ElevatorId = urandom<ElevatorId>();
    push(elevators[eid].destinations, floor);
  }
}

rule makeDemands for pid, person in people {
  match person {
    Sleeping => {},
    Waiting as w => {
      if w.destination > w.floor {
        floorControls[w.floor].upActive = True;
      } else {
        floorControls[w.floor].downActive = True;
      }
    },
    Riding as r => {
      push(elevators[r.elevator].destinations, r.destination);
    }
  }
}

rule clearControl for eid, elevator in elevators {
  match elevator.location {
    AtFloor as f => {
      if doorsOpen(f.doors) {
        match elevator.direction {
          Up => { floorControls[f.at].upActive = False; },
          Down => { floorControls[f.at].downActive = False; },
        } // direction
      }
    },
    Between => {},
  } // location
}

rule clearDestination for eid, elevator in elevators {
  match elevator.location {
    AtFloor as f => {
      if doorsOpen(f.doors) {
        remove(elevator.destinations, f.at);
      }
    },
    Between => {},
  } // location
}

rule moveDoors for eid, elevator in elevators {
  match elevator.location {
    AtFloor as f => {
      match f.doors {
        Opening as o => { 
          if past(o.doneAt) {
            f.doors = Open {
              closeAt: later(40000),
            };
          }
        },
        Open as o => {
          if past(o.closeAt) {
            f.doors = Closing {
              startAt: later(0),
              doneAt: later(20000),
            };
          }
        },
        Closing as c => {
          if past(c.doneAt) {
            f.doors = Closed;
          }
        },
        Closed => {
          if contains(elevator.destinations, f.at) {
            f.doors = Opening {
              startAt: later(0),
              doneAt: later(20000),
            };
          }
        },
      }
      elevator.location = f;
    },
    Between => {},
  }
}

rule boardOrLeave for pid, person in people {
  match person {
    Sleeping => { /* do nothing */ },
    Waiting as w => {
      for eid, elevator in elevators {
        match elevator.location {
          AtFloor as a => {
            var dirOk : Boolean;
            match elevator.direction {
              Up => { dirOk = w.destination > w.floor; },
              Down => { dirOk = w.destination < w.floor; },
            }
            if a.at == w.floor && doorsOpen(a.doors) && dirOk {
              person = Riding {
                elevator: eid,
                destination: w.destination,
              };
              push(elevator.riders, pid);
              push(elevator.destinations, w.destination);
              break;
            }
          },
          Between => { /* do nothing */ },
        }
      }
    },
    Riding as r => {
      match elevators[r.elevator].location {
        AtFloor as a => {
          if a.at == r.destination && doorsOpen(a.doors) {
            person = Sleeping {
              floor: r.destination,
            };
            remove(elevators[r.elevator].riders, pid);
          }
        },
        Between => { /* do nothing */ },
      }
    }
  }
}

invariant goSomewhereElse {
  for person in people {
    match person {
      Waiting as w => {
        assert w.floor != w.destination;
      },
      Sleeping => {},
      Riding => {},
    }
  }
}

invariant elevatorRidersCorrect {
  for pid, person in people {
    match person {
      Sleeping => {
        for elevator in elevators {
          assert !contains(elevator.riders, pid);
        }
      },
      Waiting => {
        for elevator in elevators {
          assert !contains(elevator.riders, pid);
        }
      },
      Riding as r => {
        for eid, elevator in elevators {
          if r.elevator == eid {
            assert contains(elevator.riders, pid);
          } else {
            assert !contains(elevator.riders, pid);
          }
        }
      },
    }
  }
}

